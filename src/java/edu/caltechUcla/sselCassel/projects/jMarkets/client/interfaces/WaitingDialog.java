/*
 * Copyright (C) 2005-2006, <a href="http://www.ssel.caltech.edu">SSEL</a>
 * <a href="http://www.cassel.ucla.edu">CASSEL</a>, Caltech/UCLA
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
 * USA.
 *
 * Project Authors: Raj Advani, Walter M. Yuan, and Peter Bossaerts
 * Email: jmarkets@ssel.caltech.edu
 */

/*
 * ConnectingWaitingDialog.java
 *
 * Created on June 12, 2002, 12:49 PM
 */

package edu.caltechUcla.sselCassel.projects.jMarkets.client.interfaces;

import java.awt.*;
import java.util.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;
import java.util.Random;

/**
 *
 * @author  raj
 */
public class WaitingDialog extends javax.swing.JDialog implements java.awt.event.ActionListener {
    
    /** Creates new form ConnectingWaitingDialog */
    public WaitingDialog(java.awt.Frame parent, boolean modal, String name, boolean drawVerticalLines) {
        super(parent, modal);
        this.name = name;
        initComponents();
        NameLabel.setText(name);
        upperMessage = "Connecting";
        rand = new Random();
        this.drawVerticalLines = drawVerticalLines;
        initPainter();
        this.setResizable(false);
        this.freezeMessage = false;
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {
        TitlePanel = new javax.swing.JPanel();
        NameLabel = new javax.swing.JLabel();
        DataPanel = new javax.swing.JPanel();
        
        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.Y_AXIS));
        
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                closeDialog(evt);
            }
        });
        
        TitlePanel.setMaximumSize(new java.awt.Dimension(32767, 36));
        NameLabel.setFont(new java.awt.Font("Verdana", Font.BOLD, 18));
        NameLabel.setForeground(java.awt.Color.black);
        NameLabel.setText("Client");
        TitlePanel.add(NameLabel);
        
        getContentPane().add(TitlePanel);
        
        getContentPane().add(DataPanel);
        
        //setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
    }
    
    /** Closes the dialog */
    private void closeDialog(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_closeDialog

    }//GEN-LAST:event_closeDialog
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        final WaitingDialog diag = new WaitingDialog(new javax.swing.JFrame(), true, "Test Client", false);
        
        diag.setActive("Connection Successful", "Waiting for Admin, Please be Patient", 2000);
        Runnable run = new Runnable() {
            public void run() {
                diag.setActive("Please Wait", "Testing", 5000);
                diag.setInactive();
            }
        }; 
        //Thread test = new Thread(run);
        //test.start();
        //diag.setCountdown("Game will start in:", 10);
        //diag.setInactive();
    }
    
    /** Initializes the painting algorithm in the DataPanel */
    private void initPainter() {
        getContentPane().remove(DataPanel);
        
        topx1 = 0;
        topx2 = 120;
        bottomx1 = 150;
        bottomx2 = 0;
        timer = new javax.swing.Timer(10, this);
        timer.start();
        
        DataPanel = new JPanel() {
            public void paint(Graphics g) {
                super.paint(g);
                Graphics2D g2d = (Graphics2D) g;
                
                panelLength = getSize().width;
                panelHeight = getSize().height;
                
                g2d.setStroke(new BasicStroke(10));
                
                GradientPaint topBarPaint = new GradientPaint(topx1, topy1, Color.black, topx2, topy2, Color.blue, true);
                
                g2d.setPaint(topBarPaint);
                g2d.drawLine(0, 0, panelLength, 0);
                
                GradientPaint bottomBarPaint = new GradientPaint(bottomx1, bottomy1, Color.black, bottomx2, bottomy2, Color.blue, true);
                
                g2d.setPaint(bottomBarPaint);
                g2d.drawLine(0, panelHeight, panelLength, panelHeight);
                
                if (drawVerticalLines) {
                    GradientPaint verticalBarPaint = new GradientPaint(0, 0, Color.black, 0, panelHeight, Color.lightGray, true);
                    
                    g2d.setStroke(new BasicStroke(2));
                    g2d.setPaint(verticalBarPaint);
                    g2d.drawLine(vertx1, 6, vertx2, panelHeight - 6);
                    g2d.drawLine(vert2x1, 6, vert2x2, panelHeight - 6);
                }
                
                g2d.setPaint(new GradientPaint(50, 0, Color.darkGray, 450, 0, Color.black));
                g2d.setFont(new Font("Verdana", 0, 18));
                
                double strWidth = g2d.getFontMetrics().getStringBounds(upperMessage, g2d).getWidth();
                g2d.drawString(upperMessage, (float) (panelLength / 2) - (float) (strWidth / 2), (float) panelHeight / 3);
                
                strWidth = g2d.getFontMetrics().getStringBounds(lowerMessage, g2d).getWidth();
                g2d.drawString(lowerMessage, (float) (panelLength / 2) - (float) (strWidth / 2), (float) panelHeight / (1.5f));
            }
        };
        
        DataPanel.setMinimumSize(new Dimension(450, 100));
        DataPanel.setPreferredSize(new Dimension(450, 100));
        DataPanel.setMaximumSize(new Dimension(450, 100));
        
        getContentPane().add(DataPanel);
        this.pack();
        centerOnScreen();
    }
    
    /** Activates the screen with the given messages. If there is a message currently
     *  frozen in place, then hold the calling thread until the frozen message expires
     *  then write this new message */
    public void setActive(String upperMessage, String lowerMessage) {
        thaw();
        
        this.upperMessage = upperMessage;
        this.lowerMessage = lowerMessage;
        
        Runnable doUpdate = new Runnable() {
            public void run() {
                setVisible(true);
                repaint();
            }
        };
        SwingUtilities.invokeLater(doUpdate);
    }
    
    /** Wait for the frozen message (if there is one) to expire then return */
    private synchronized void thaw() {
        try {
            while (freezeMessage)
                wait(1000);
        }catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    /** Activates the screen with the given messages and holds the message in
     *  place for the given number of milliseconds. This is accomplished by holding
     *  the calling thread for that amount of time and setting the boolean freezeMessage
     *  to true so that no other thread can modify the message */
    public synchronized void setActive(String upperMessage, String lowerMessage, long time) {
        try {
            setActive(upperMessage, lowerMessage);
            freezeMessage = true;
            wait(time);
            freezeMessage = false;
        }catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    /** Activates the screen with the given top message and a lower message that serves
     *  as a countdown timer for the given number of seconds. After that amount of seconds has
     *  elapsed, control of the calling thread is released */
    public synchronized void setCountdown(String umessage, int seconds) {
        try {
            thaw();
            this.secondsRemaining = seconds;
            long time = seconds * 1000;
            final String message = umessage;
            freezeMessage = true;
            
            countdownTimer = new java.util.Timer();
            
            TimerTask task = new TimerTask() {
                public void run() {
                    if (secondsRemaining <= 0) {
                        freezeMessage = false;
                        countdownTimer.cancel();
                    }
                    
                    upperMessage = message;
                    if (secondsRemaining != 1)
                        lowerMessage = secondsRemaining + " seconds";
                    else
                        lowerMessage = secondsRemaining + " second";
                    
                    Runnable doUpdate = new Runnable() {
                        public void run() {
                            if (!isVisible())
                                setVisible(true);
                        }
                    };
                    SwingUtilities.invokeLater(doUpdate);
                    secondsRemaining--;
                }
            };
            
            countdownTimer.schedule(task, 0, 1000);
            
            while (freezeMessage)
                wait(1000);
            
        }catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    /** Hides the screen */
    public void setInactive() {
        thaw();
        
        Runnable doUpdate = new Runnable() {
            public void run() {
                setVisible(false);
            }
        };
        SwingUtilities.invokeLater(doUpdate);
    }
    
    /** Hides the screen and disposes it */
    public void kill() {
        thaw();
        
        Runnable doUpdate = new Runnable() {
            public void run() {
                setVisible(false);
                timer.stop();
                dispose();
            }
        };
        SwingUtilities.invokeLater(doUpdate);
    }
    
    /* Center on the screen */
    public void centerOnScreen() {
        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension window = this.getSize();
        int iCenterX = screen.width / 2;
        int iCenterY = screen.height / 2;
        setLocation(iCenterX - (window.width / 2),
        iCenterY - (window.height / 2));
    }
    
    public void actionPerformed(java.awt.event.ActionEvent actionEvent) {
        topx1+=2;
        topy1 = 0;
        topx2+=2;
        topy2 = 0;
        
        bottomx1++;
        bottomy1 = panelHeight;
        bottomx2++;
        bottomy2 = panelHeight;
        
        int moveAmount = 11;
        int moveAmount2 = 6;
        
        if (vertx1 > panelLength || vertx2 > panelLength) {
            movingForward = false;
            vertx1-=moveAmount;
            vertx2-=moveAmount;
        }
        else if (vertx1 < 0 || vertx2 < 0) {
            movingForward = true;
            vertx1+=moveAmount;
            vertx2+=moveAmount;
        }
        else if (movingForward) {
            vertx1+=moveAmount;
            vertx2+=moveAmount;
        }
        else {
            vertx1-=moveAmount;
            vertx2-=moveAmount;
        }
        
        if (vert2x1 > panelLength || vert2x2 > panelLength) {
            movingForward2 = false;
            vert2x1-=moveAmount2;
            vert2x2-=moveAmount2;
        }
        else if (vert2x1 < 0 || vert2x2 < 0) {
            movingForward2 = true;
            vert2x1+=moveAmount2;
            vert2x2+=moveAmount2;
        }
        else if (movingForward2) {
            vert2x1+=moveAmount2;
            vert2x2+=moveAmount2;
        }
        else {
            vert2x1-=moveAmount2;
            vert2x2-=moveAmount2;
        }
        
        repaint();
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel TitlePanel;
    private javax.swing.JPanel DataPanel;
    private javax.swing.JLabel NameLabel;
    // End of variables declaration//GEN-END:variables
    
    private String name;
    private String upperMessage;
    private String lowerMessage;
    
    private boolean freezeMessage;
    
    /** The seconds remaining in a countdown message */
    private int secondsRemaining;
    
    /** The timer used for the countdown message */
    private java.util.Timer countdownTimer;
    
    /** Cosmetic variables */
    private javax.swing.Timer timer;
    private float topx1, topy1, topx2, topy2, bottomx1, bottomy1, bottomx2, bottomy2;
    private int vertx1, vertx2, vert2x1, vert2x2;
    private int panelHeight, panelLength;
    private Random rand;
    private boolean movingForward, movingForward2;
    
    /** Set to true in constructor to draw the vertical moving lines (purely cosmetic) */
    private boolean drawVerticalLines;
}
